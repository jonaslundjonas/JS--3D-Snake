<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Snake 3D - Neon Cyberpunk Edition</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- Post-processing effects -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">

    <script>
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: {
              'orbitron': ['Orbitron', 'monospace'],
            },
            keyframes: {
              gradient: {
                '0%': { 'background-position': '0% 50%' },
                '50%': { 'background-position': '100% 50%' },
                '100%': { 'background-position': '0% 50%' },
              },
              fadeIn: {
                'from': { opacity: '0', transform: 'translate(-50%, -50%) scale(0.95)' },
                'to': { opacity: '1', transform: 'translate(-50%, -50%) scale(1)' },
              },
              pausePulse: {
                '0%, 100%': { transform: 'scale(1)', opacity: '1' },
                '50%': { transform: 'scale(1.05)', opacity: '0.8' },
              },
              spin: {
                '0%': { transform: 'rotate(0deg)' },
                '100%': { transform: 'rotate(360deg)' },
              },
              pulse: {
                '0%, 100%': { opacity: '1' },
                '50%': { opacity: '0.5' },
              }
            },
            animation: {
              'gradient': 'gradient 3s ease infinite',
              'fadeIn': 'fadeIn 0.5s ease-out forwards',
              'pausePulse': 'pausePulse 1s ease-in-out infinite',
              'spin': 'spin 1s linear infinite',
              'pulse': 'pulse 1.5s ease-in-out infinite',
            }
          },
        },
      }
    </script>
    <style type="text/tailwindcss">
        body {
            @apply font-orbitron bg-black text-white antialiased select-none;
        }
        /* Custom text shadow utility */
        .text-shadow-cyan {
          text-shadow: 0 0 10px #00ffff;
        }
        .text-shadow-pink {
          text-shadow: 0 0 50px rgba(255, 0, 255, 0.5);
        }
        .text-shadow-yellow {
          text-shadow: 0 0 30px #ffff00;
        }
        .text-shadow-red {
          text-shadow: 0 0 30px #ff0066;
        }
    </style>
</head>
<body class="overflow-hidden">
    <div id="loadingScreen" class="fixed top-0 left-0 w-full h-full bg-gradient-to-br from-[#0a0a0a] to-[#1a0a2a] flex justify-center items-center z-50 transition-opacity duration-500">
        <div class="text-center">
            <div class="w-24 h-24 border-4 border-pink-500 rounded-full border-t-transparent animate-spin mx-auto mb-5 shadow-[0_0_30px_#ff00ff,inset_0_0_30px_#ff00ff]"></div>
            <div class="text-cyan-400 text-2xl tracking-[3px] animate-pulse">
                LOADING SNAKE 3D
            </div>
        </div>
    </div>

    <div id="gameUI" class="fixed top-0 left-0 w-full h-full z-10 pointer-events-none">
        <div id="pauseBtn" class="md:hidden absolute top-5 right-5 pointer-events-auto bg-black/70 border-2 border-yellow-300 rounded-xl p-3">
            <svg class="w-6 h-6 text-yellow-300" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 9v6m4-6v6"></path></svg>
        </div>

        <div class="absolute top-5 left-1/2 -translate-x-1/2 flex flex-col md:flex-row items-center gap-4 md:gap-8 pointer-events-auto">
            <div class="bg-black/70 border-2 border-cyan-400 rounded-xl py-2 px-6 md:py-4 md:px-8 backdrop-blur-lg shadow-[0_0_20px_rgba(0,255,255,0.5)] text-center">
                <div class="text-xs text-cyan-400 tracking-[2px] mb-1">SCORE</div>
                <div id="score" class="text-xl md:text-3xl font-black text-white text-shadow-cyan">0</div>
            </div>
            <div class="bg-black/70 border-2 border-cyan-400 rounded-xl py-2 px-6 md:py-4 md:px-8 backdrop-blur-lg shadow-[0_0_20px_rgba(0,255,255,0.5)] text-center">
                <div class="text-xs text-cyan-400 tracking-[2px] mb-1">HIGH SCORE</div>
                <div id="highScore" class="text-xl md:text-3xl font-black text-white text-shadow-cyan">0</div>
            </div>
            <div class="bg-black/70 border-2 border-cyan-400 rounded-xl py-2 px-6 md:py-4 md:px-8 backdrop-blur-lg shadow-[0_0_20px_rgba(0,255,255,0.5)] text-center">
                <div class="text-xs text-cyan-400 tracking-[2px] mb-1">LEVEL</div>
                <div id="level" class="text-xl md:text-3xl font-black text-white text-shadow-cyan">1</div>
            </div>
            <div class="bg-black/70 border-2 border-cyan-400 rounded-xl py-2 px-6 md:py-4 md:px-8 backdrop-blur-lg shadow-[0_0_20px_rgba(0,255,255,0.5)] text-center">
                <div class="text-xs text-cyan-400 tracking-[2px] mb-1">LIVES</div>
                <div id="lives" class="text-xl md:text-3xl font-black text-white text-shadow-cyan">3</div>
            </div>
        </div>

        <div id="startMenu" class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-full max-w-2xl px-4 text-center pointer-events-auto animate-fadeIn">
            <h1 class="text-6xl md:text-8xl font-black bg-gradient-to-r from-pink-500 via-cyan-400 to-pink-500 bg-clip-text text-transparent animate-gradient bg-[200%_200%] text-shadow-pink mb-2.5">
                SNAKE 3D
            </h1>
            <div class="text-lg md:text-xl text-cyan-400 tracking-[5px] mb-10 text-shadow-cyan">
                NEON CYBERPUNK EDITION
            </div>
            <button onclick="startGame()" class="relative bg-gradient-to-r from-pink-500 to-cyan-400 border-none py-5 px-16 font-orbitron text-2xl font-bold text-white tracking-[3px] rounded-full cursor-pointer overflow-hidden transition-all duration-300 m-5 hover:scale-105 hover:shadow-[0_10px_40px_rgba(255,0,255,0.6)] group">
                <span class="relative z-10">PLAY</span>
                <span class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-full h-full bg-[radial-gradient(circle,rgba(255,255,255,0.3)_0%,transparent_70%)] opacity-0 transition-opacity duration-300 group-hover:opacity-100"></span>
            </button>
            <div class="mt-10 bg-black/50 border border-cyan-400 rounded-lg p-5 backdrop-blur-md max-w-sm mx-auto">
                <div class="m-2 text-cyan-400 text-sm tracking-wider">←→ or A/D - Steer Left/Right</div>
                <div class="m-2 text-cyan-400 text-sm tracking-wider">SPACE - Pause</div>
            </div>
            <div class="mt-6 text-cyan-400 text-xs tracking-widest opacity-70">
                Created by Jonas Lund 2025
            </div>
        </div>

        <div id="gameOverMenu" class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-center pointer-events-auto animate-fadeIn" style="display: none;">
            <h1 class="text-6xl font-black text-red-500 text-shadow-red mb-5">
                GAME OVER
            </h1>
            <div class="text-3xl text-cyan-400 mb-8 text-shadow-cyan">
                FINAL SCORE: <span id="finalScore" class="font-bold">0</span>
            </div>
            <button onclick="restartGame()" class="relative bg-gradient-to-r from-pink-500 to-cyan-400 border-none py-5 px-16 font-orbitron text-2xl font-bold text-white tracking-[3px] rounded-full cursor-pointer overflow-hidden transition-all duration-300 m-5 hover:scale-105 hover:shadow-[0_10px_40px_rgba(255,0,255,0.6)] group">
                <span class="relative z-10">PLAY AGAIN</span>
                <span class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-full h-full bg-[radial-gradient(circle,rgba(255,255,255,0.3)_0%,transparent_70%)] opacity-0 transition-opacity duration-300 group-hover:opacity-100"></span>
            </button>
        </div>

        <div id="pauseIndicator" class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-center" style="display: none;">
            <div class="text-6xl font-black text-yellow-300 text-shadow-yellow animate-pausePulse">
                PAUSED
            </div>
            <div class="text-lg text-white mt-5 tracking-[2px]">
                Press SPACE to Resume
            </div>
        </div>

        <div id="touchControls" class="md:hidden fixed bottom-0 left-0 w-full h-1/4 pointer-events-auto flex">
            <div id="touchLeft" class="w-1/2 h-full bg-cyan-400/10"></div>
            <div class="w-px h-full bg-cyan-400/20"></div>
            <div id="touchRight" class="w-1/2 h-full bg-pink-500/10"></div>
        </div>
    </div>

    <div id="gameCanvas" class="fixed top-0 left-0 w-full h-full z-0"></div>

    <script>
        // --- GAME VARIABLES ---
        let scene, camera, renderer, composer, starfield;
        let snake = [];
        let food, foodGlow;
        let bonusFood, bonusFoodGlow, bonusFoodTimeout;
        let direction = { x: 1, y: 0, z: 0 };
        let newDirection = { x: 1, y: 0, z: 0 };
        let score = 0;
        let highScore = localStorage.getItem('snake3DHighScore') || 0;
        let level = 1;
        let lives = 3;
        let gameRunning = false;
        let isPaused = false;
        let gameSpeed = 150;
        let lastUpdateTime = 0;
        let gridSize = 20;
        let particleSystems = [];
        
        // --- CONSTANTS ---
        const snakeHeadColor = 0x00ff00;
        const snakeBodyColor = 0x00aa00;
        const foodColor = 0xff00ff;
        const bonusFoodColor = 0xffd700; // Gold
        const bonusFoodValue = 50;
        const bonusFoodDuration = 10000; // 10 seconds
        const gridColor = 0x003366;
        
        // --- AUDIO ---
        let audioContext;
        let mainGainNode;

        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                mainGainNode = audioContext.createGain();
                mainGainNode.connect(audioContext.destination);
                mainGainNode.gain.value = 0.5;
            }
        }

        function playSound(type) {
            if (!audioContext) return;
            if (audioContext.state === 'suspended') audioContext.resume();
            
            const now = audioContext.currentTime;
            switch(type) {
                case 'eat': {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    osc.connect(gain);
                    gain.connect(mainGainNode);
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(880, now);
                    gain.gain.setValueAtTime(0.3, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                    osc.start(now);
                    osc.stop(now + 0.2);
                    break;
                }
                case 'bonus_eat': {
                    [1046.50, 1318.51, 1567.98].forEach((freq, i) => {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        osc.connect(gain);
                        gain.connect(mainGainNode);
                        osc.type = 'triangle';
                        osc.frequency.setValueAtTime(freq, now + i * 0.07);
                        gain.gain.setValueAtTime(0.3, now + i * 0.07);
                        gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.07 + 0.1);
                        osc.start(now + i * 0.07);
                        osc.stop(now + i * 0.07 + 0.1);
                    });
                    break;
                }
                case 'explode': {
                    const noiseSource = audioContext.createBufferSource();
                    const bufferSize = audioContext.sampleRate * 0.5;
                    const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                    const output = buffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) output[i] = Math.random() * 2 - 1;
                    noiseSource.buffer = buffer;
                    const gain = audioContext.createGain();
                    const filter = audioContext.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.value = 400;
                    noiseSource.connect(filter);
                    filter.connect(gain);
                    gain.connect(mainGainNode);
                    gain.gain.setValueAtTime(0.6, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                    noiseSource.start(now);
                    noiseSource.stop(now + 0.5);
                    break;
                }
                case 'gameover': {
                     [220, 164.81, 110].forEach((freq, i) => {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        osc.connect(gain);
                        gain.connect(mainGainNode);
                        osc.type = 'square';
                        osc.frequency.setValueAtTime(freq, now + i * 0.2);
                        gain.gain.setValueAtTime(0.4, now + i * 0.2);
                        gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.2 + 0.3);
                        osc.start(now + i * 0.2);
                        osc.stop(now + i * 0.2 + 0.3);
                    });
                    break;
                }
            }
        }
        
        // --- INITIALIZATION ---
        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 20, 60);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 18);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ReinhardToneMapping;
            renderer.toneMappingExposure = 2;
            document.getElementById('gameCanvas').appendChild(renderer.domElement);

            setupPostProcessing();
            setupLighting();
            createGameBoard();
            createStarfield();
            createSnake();
            createFood();

            document.addEventListener('keydown', handleKeyPress);
            window.addEventListener('resize', onWindowResize);

            document.getElementById('touchLeft').addEventListener('touchstart', (e) => handleTouch(e, 'left'));
            document.getElementById('touchRight').addEventListener('touchstart', (e) => handleTouch(e, 'right'));
            document.getElementById('pauseBtn').addEventListener('touchstart', (e) => handleTouch(e, 'pause'));

            document.getElementById('highScore').textContent = highScore;
            document.getElementById('lives').textContent = lives;

            setTimeout(() => {
                document.getElementById('loadingScreen').style.opacity = '0';
                setTimeout(() => {
                    document.getElementById('loadingScreen').style.display = 'none';
                }, 500);
            }, 1000);

            animate();
        }

        function setupPostProcessing() {
            composer = new THREE.EffectComposer(renderer);
            const renderPass = new THREE.RenderPass(scene, camera);
            composer.addPass(renderPass);
            const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            composer.addPass(bloomPass);
        }

        function setupLighting() {
            scene.add(new THREE.AmbientLight(0x404040, 0.5));
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);
            const rimLight1 = new THREE.PointLight(0xff00ff, 1, 50);
            rimLight1.position.set(-20, 10, -20);
            scene.add(rimLight1);
            const rimLight2 = new THREE.PointLight(0x00ffff, 1, 50);
            rimLight2.position.set(20, 10, 20);
            scene.add(rimLight2);
        }

        // --- GAME OBJECT CREATION ---
        function createGameBoard() {
            const gridGeometry = new THREE.PlaneGeometry(gridSize, gridSize);
            const gridMaterial = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.8, roughness: 0.2, emissive: gridColor, emissiveIntensity: 0.1 });
            const grid = new THREE.Mesh(gridGeometry, gridMaterial);
            grid.rotation.x = -Math.PI / 2;
            grid.position.y = -0.5;
            grid.receiveShadow = true;
            scene.add(grid);

            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x00ffff, opacity: 0.3, transparent: true });
            for (let i = 0; i <= gridSize; i++) {
                const hPoints = [new THREE.Vector3(-gridSize/2, 0, -gridSize/2 + i), new THREE.Vector3(gridSize/2, 0, -gridSize/2 + i)];
                scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(hPoints), lineMaterial));
                const vPoints = [new THREE.Vector3(-gridSize/2 + i, 0, -gridSize/2), new THREE.Vector3(-gridSize/2 + i, 0, gridSize/2)];
                scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(vPoints), lineMaterial));
            }

            const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 0.5, transparent: true, opacity: 0.2 });
            const wallHeight = 3, wallThickness = 0.1;
            const northWall = new THREE.Mesh(new THREE.BoxGeometry(gridSize + 2, wallHeight, wallThickness), wallMaterial);
            northWall.position.set(0, wallHeight/2 - 0.5, gridSize/2 + 0.5);
            scene.add(northWall);
            const southWall = new THREE.Mesh(new THREE.BoxGeometry(gridSize + 2, wallHeight, wallThickness), wallMaterial);
            southWall.position.set(0, wallHeight/2 - 0.5, -gridSize/2 - 0.5);
            scene.add(southWall);
            const eastWall = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, wallHeight, gridSize + 2), wallMaterial);
            eastWall.position.set(gridSize/2 + 0.5, wallHeight/2 - 0.5, 0);
            scene.add(eastWall);
            const westWall = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, wallHeight, gridSize + 2), wallMaterial);
            westWall.position.set(-gridSize/2 - 0.5, wallHeight/2 - 0.5, 0);
            scene.add(westWall);
        }

        function createStarfield() {
            const starVertices = [], starColors = [];
            const zMin = -200, zMax = 20;
            for (let i = 0; i < 1500; i++) {
                starVertices.push(THREE.MathUtils.randFloatSpread(150), THREE.MathUtils.randFloatSpread(150), THREE.MathUtils.randFloat(zMin, zMax));
                const intensity = (starVertices[starVertices.length - 1] - zMin) / (zMax - zMin);
                starColors.push(intensity, intensity, intensity);
            }
            const starGeometry = new THREE.BufferGeometry();
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            starGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
            const starMaterial = new THREE.PointsMaterial({ size: 0.15, vertexColors: true, fog: false });
            starfield = new THREE.Points(starGeometry, starMaterial);
            scene.add(starfield);
        }

        function createSnake() {
            snake.forEach(segment => scene.remove(segment.mesh));
            snake = [];
            [{ pos: { x: 0, y: 0, z: 0 }, isHead: true }, { pos: { x: -1, y: 0, z: 0 }, isHead: false }, { pos: { x: -2, y: 0, z: 0 }, isHead: false }].forEach(data => {
                const isHead = data.isHead;
                const geometry = new THREE.BoxGeometry(0.9, 0.9, 0.9);
                const material = new THREE.MeshStandardMaterial({ color: isHead ? snakeHeadColor : snakeBodyColor, emissive: isHead ? snakeHeadColor : snakeBodyColor, emissiveIntensity: isHead ? 0.5 : 0.3, metalness: isHead ? 0.8 : 0.6, roughness: isHead ? 0.2 : 0.3 });
                const segment = new THREE.Mesh(geometry, material);
                segment.castShadow = true;
                segment.position.set(data.pos.x - gridSize / 2 + 0.5, 0.45, data.pos.z - gridSize / 2 + 0.5);
                scene.add(segment);
                snake.push({ position: data.pos, mesh: segment });
            });
        }
        
        function addSnakeSegment() {
            const tail = snake[snake.length - 1];
            const geometry = new THREE.BoxGeometry(0.9, 0.9, 0.9);
            const material = new THREE.MeshStandardMaterial({ color: snakeBodyColor, emissive: snakeBodyColor, emissiveIntensity: 0.3, metalness: 0.6, roughness: 0.3 });
            const segment = new THREE.Mesh(geometry, material);
            segment.castShadow = true;
            segment.position.copy(tail.mesh.position);
            scene.add(segment);
            snake.push({ position: { ...tail.position }, mesh: segment });
        }

        function createFood() {
            if (food) { scene.remove(food); scene.remove(foodGlow); }
            let x, z;
            do {
                x = Math.floor(Math.random() * gridSize);
                z = Math.floor(Math.random() * gridSize);
            } while (snake.some(s => s.position.x === x && s.position.z === z) || (bonusFood && bonusFood.gridPosition.x === x && bonusFood.gridPosition.z === z));
            const foodGeometry = new THREE.OctahedronGeometry(0.4, 0);
            const foodMaterial = new THREE.MeshStandardMaterial({ color: foodColor, emissive: foodColor, emissiveIntensity: 0.8, metalness: 1, roughness: 0 });
            food = new THREE.Mesh(foodGeometry, foodMaterial);
            food.position.set(x - gridSize/2 + 0.5, 0.5, z - gridSize/2 + 0.5);
            food.castShadow = true;
            scene.add(food);
            const glowGeometry = new THREE.SphereGeometry(0.8, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({ color: foodColor, transparent: true, opacity: 0.3 });
            foodGlow = new THREE.Mesh(glowGeometry, glowMaterial);
            foodGlow.position.copy(food.position);
            scene.add(foodGlow);
            food.gridPosition = { x, z };
        }

        function createBonusFood() {
            if (bonusFood) return;
            let x, z;
            do {
                x = Math.floor(Math.random() * gridSize);
                z = Math.floor(Math.random() * gridSize);
            } while (snake.some(s => s.position.x === x && s.position.z === z) || (food && food.gridPosition.x === x && food.gridPosition.z === z));
            const geometry = new THREE.TorusGeometry(0.3, 0.1, 8, 16);
            const material = new THREE.MeshStandardMaterial({ color: bonusFoodColor, emissive: bonusFoodColor, emissiveIntensity: 1, metalness: 1, roughness: 0 });
            bonusFood = new THREE.Mesh(geometry, material);
            bonusFood.position.set(x - gridSize/2 + 0.5, 0.5, z - gridSize/2 + 0.5);
            bonusFood.rotation.x = Math.PI / 2;
            bonusFood.castShadow = true;
            scene.add(bonusFood);
            const glowGeometry = new THREE.SphereGeometry(0.7, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({ color: bonusFoodColor, transparent: true, opacity: 0.4 });
            bonusFoodGlow = new THREE.Mesh(glowGeometry, glowMaterial);
            bonusFoodGlow.position.copy(bonusFood.position);
            scene.add(bonusFoodGlow);
            bonusFood.gridPosition = { x, z };
            bonusFoodTimeout = setTimeout(removeBonusFood, bonusFoodDuration);
        }

        function removeBonusFood() {
            if (bonusFood) {
                scene.remove(bonusFood);
                scene.remove(bonusFoodGlow);
                bonusFood = null;
                bonusFoodGlow = null;
                clearTimeout(bonusFoodTimeout);
            }
        }
        
        // --- GAME LOGIC ---
        function moveSnake() {
            if (!gameRunning || isPaused) return;
            direction = { ...newDirection };
            const head = snake[0];
            const newX = head.position.x + direction.x;
            const newZ = head.position.z + direction.z;

            if (newX < 0 || newX >= gridSize || newZ < 0 || newZ >= gridSize || snake.slice(1).some(s => s.position.x === newX && s.position.z === newZ)) {
                handleDeath();
                return;
            }

            const tail = snake.pop();
            tail.position = { x: newX, y: 0, z: newZ };
            snake.unshift(tail);
            for(let i=0; i < snake.length; i++) {
                snake[i].mesh.position.set(snake[i].position.x - gridSize/2 + 0.5, 0.45, snake[i].position.z - gridSize/2 + 0.5);
            }

            if (direction.x === 1) snake[0].mesh.rotation.y = Math.PI / 2;
            else if (direction.x === -1) snake[0].mesh.rotation.y = -Math.PI / 2;
            else if (direction.z === 1) snake[0].mesh.rotation.y = Math.PI;
            else if (direction.z === -1) snake[0].mesh.rotation.y = 0;

            if (bonusFood && newX === bonusFood.gridPosition.x && newZ === bonusFood.gridPosition.z) {
                eatBonusFood();
            }
            if (newX === food.gridPosition.x && newZ === food.gridPosition.z) {
                eatFood();
            }
        }
        
        function eatFood() {
            playSound('eat');
            score += 10;
            document.getElementById('score').textContent = score;
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('snake3DHighScore', highScore);
                document.getElementById('highScore').textContent = highScore;
            }
            level = Math.floor(score / 50) + 1;
            document.getElementById('level').textContent = level;
            gameSpeed = Math.max(50, 150 - level * 10);
            
            if (!bonusFood && Math.random() < 0.25) createBonusFood();

            createFoodParticles(food.position, foodColor);
            addSnakeSegment();
            createFood();
        }

        function eatBonusFood() {
            playSound('bonus_eat');
            score += bonusFoodValue;
            document.getElementById('score').textContent = score;
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('snake3DHighScore', highScore);
                document.getElementById('highScore').textContent = highScore;
            }
            level = Math.floor(score / 50) + 1;
            document.getElementById('level').textContent = level;
            gameSpeed = Math.max(50, 150 - level * 10);
            createFoodParticles(bonusFood.position, bonusFoodColor);
            removeBonusFood();
        }

        function handleDeath() {
            playSound('explode');
            lives--;
            document.getElementById('lives').textContent = lives;
            isPaused = true; 
            createExplosion(snake[0].mesh.position);
            snake.forEach(segment => segment.mesh.visible = false);
            if (lives <= 0) {
                setTimeout(() => { isPaused = false; gameOver(); }, 2000); 
            } else {
                setTimeout(resetAfterDeath, 2000);
            }
        }

        function resetAfterDeath() {
            removeBonusFood();
            direction = { x: 1, y: 0, z: 0 };
            newDirection = { x: 1, y: 0, z: 0 };
            createSnake();
            isPaused = false;
        }

        function handleKeyPress(event) {
            if (!gameRunning || (isPaused && event.key.toLowerCase() !== ' ')) return;
            switch(event.key.toLowerCase()) {
                case 'arrowleft': case 'a':
                    if (!isPaused) newDirection = { x: direction.z, y: 0, z: -direction.x };
                    break;
                case 'arrowright': case 'd':
                    if (!isPaused) newDirection = { x: -direction.z, y: 0, z: direction.x };
                    break;
                case ' ':
                    isPaused = !isPaused;
                    document.getElementById('pauseIndicator').style.display = isPaused ? 'block' : 'none';
                    break;
            }
        }

        function handleTouch(event, action) {
            event.preventDefault();
            if (!gameRunning) return;

            switch(action) {
                case 'left':
                    if (!isPaused) newDirection = { x: direction.z, y: 0, z: -direction.x };
                    break;
                case 'right':
                    if (!isPaused) newDirection = { x: -direction.z, y: 0, z: direction.x };
                    break;
                case 'pause':
                    isPaused = !isPaused;
                    document.getElementById('pauseIndicator').style.display = isPaused ? 'block' : 'none';
                    break;
            }
        }

        function startGame() {
            initAudio();
            document.getElementById('startMenu').style.display = 'none';
            gameRunning = true;
            isPaused = false;
            lives = 3;
            document.getElementById('lives').textContent = lives;
        }

        function gameOver() {
            playSound('gameover');
            gameRunning = false;
            document.getElementById('finalScore').textContent = score;
            document.getElementById('gameOverMenu').style.display = 'block';
        }

        function restartGame() {
            document.getElementById('gameOverMenu').style.display = 'none';
            direction = { x: 1, y: 0, z: 0 };
            newDirection = { x: 1, y: 0, z: 0 };
            score = 0; level = 1; lives = 3; gameSpeed = 150;
            removeBonusFood();
            createSnake();
            createFood();
            document.getElementById('score').textContent = score;
            document.getElementById('level').textContent = level;
            document.getElementById('lives').textContent = lives;
            gameRunning = true;
            isPaused = false;
        }

        // --- PARTICLE EFFECTS ---
        function createExplosion(position) {
            const particleCount = 100;
            const geometry = new THREE.BufferGeometry();
            const positions = [], velocities = [];
            for (let i = 0; i < particleCount; i++) {
                positions.push(position.x, position.y, position.z);
                velocities.push((Math.random() - 0.5) * 15, (Math.random() - 0.5) * 15, (Math.random() - 0.5) * 15);
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({ size: 0.15, color: snakeHeadColor, transparent: true });
            const particles = new THREE.Points(geometry, material);
            particles.userData = { velocities, life: 1.0 };
            scene.add(particles);
            particleSystems.push(particles);
        }

        function createFoodParticles(position, color) {
            const particleCount = 20;
            const geometry = new THREE.BufferGeometry();
            const positions = [], velocities = [];
            for (let i = 0; i < particleCount; i++) {
                positions.push(position.x, position.y, position.z);
                velocities.push((Math.random() - 0.5) * 5, Math.random() * 5, (Math.random() - 0.5) * 5);
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({ size: 0.1, color: color, transparent: true });
            const particles = new THREE.Points(geometry, material);
            particles.userData = { velocities, life: 1.0 };
            scene.add(particles);
            particleSystems.push(particles);
        }

        function updateParticles(deltaTime) {
            particleSystems = particleSystems.filter(system => {
                system.userData.life -= deltaTime * 1.5;
                if (system.userData.life <= 0) {
                    scene.remove(system);
                    return false;
                }
                const positions = system.geometry.attributes.position.array;
                for (let i = 0; i < positions.length; i += 3) {
                    positions[i] += system.userData.velocities[i] * deltaTime;
                    positions[i+1] += system.userData.velocities[i+1] * deltaTime;
                    positions[i+2] += system.userData.velocities[i+2] * deltaTime;
                }
                system.geometry.attributes.position.needsUpdate = true;
                system.material.opacity = system.userData.life;
                return true;
            });
        }

        // --- RENDER LOOP ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animateStarfield(deltaTime) {
            if (!starfield) return;
            const positions = starfield.geometry.attributes.position.array;
            const colors = starfield.geometry.attributes.color.array;
            const speed = 15;
            const zMin = -200, zMax = 20;
            for (let i = 0; i < positions.length; i += 3) {
                positions[i + 2] += speed * deltaTime;
                if (positions[i + 2] > zMax) {
                    positions[i + 2] = zMin;
                    positions[i] = THREE.MathUtils.randFloatSpread(150);
                    positions[i + 1] = THREE.MathUtils.randFloatSpread(150);
                }
                const intensity = (positions[i + 2] - zMin) / (zMax - zMin);
                colors[i] = colors[i + 1] = colors[i + 2] = intensity;
            }
            starfield.geometry.attributes.position.needsUpdate = true;
            starfield.geometry.attributes.color.needsUpdate = true;
        }

        let lastFrameTime = 0;
        function animate(currentTime) {
            requestAnimationFrame(animate);
            const deltaTime = (currentTime - lastFrameTime) * 0.001 || 0;
            lastFrameTime = currentTime;

            if (currentTime - lastUpdateTime > gameSpeed) {
                moveSnake();
                lastUpdateTime = currentTime;
            }

            if (food) {
                food.rotation.x += 0.02;
                food.rotation.y += 0.02;
                food.position.y = 0.5 + Math.sin(currentTime * 0.003) * 0.1;
                foodGlow.position.copy(food.position);
                const scale = 1 + Math.sin(currentTime * 0.005) * 0.2;
                foodGlow.scale.set(scale, scale, scale);
            }
            if (bonusFood) {
                bonusFood.rotation.z += 0.05;
                bonusFood.position.y = 0.5 + Math.sin(currentTime * 0.004) * 0.15;
                bonusFoodGlow.position.copy(bonusFood.position);
            }
            
            animateStarfield(deltaTime);
            updateParticles(deltaTime);
            composer.render();
        }

        window.addEventListener('load', init);
    </script>
</body>
</html>